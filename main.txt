#define _GNU_SOURCE
#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <getopt.h>

#define SEGMENT_SIZE (1024 * 1024) // 1MB segments
#define BLOCK_SIZE 4096            // 4KB blocks
#define INODE_SIZE BLOCK_SIZE      // Each inode is one block
#define DATA_SIZE BLOCK_SIZE       // Each inode is one block

#define MAX_DIRECT_BLOCKS ((INODE_SIZE - 160) / sizeof(uint32_t)) // Rough estimate, adjust based on attributes

// Define inode file index structure and bitmap
#define MAX_INODES (SEGMENT_SIZE / INODE_SIZE) // Maximum inodes in 1MB
#define BITMAP_BYTES (MAX_INODES - 1)          // Size of bitmap in bytes

/* File types */
#define FILE_TYPE_REGULAR 1
#define FILE_TYPE_DIRECTORY 2

/* Segment file name pattern */
#define INODE_SEGMENT_NAME_PATTERN "inodeseg%d"
#define DATA_SEGMENT_NAME_PATTERN "dataseg%d"

typedef struct
{
    uint32_t type;                             // File type (regular or directory)
    uint64_t size;                             // File size in bytes
    uint32_t direct_blocks[MAX_DIRECT_BLOCKS]; // Direct block pointers
    uint32_t single_indirect;                  // Single indirect block
    uint32_t double_indirect;                  // Double indirect block
    // uint32_t triple_indirect;                  // Triple indirect block
    // Add other necessary fields here
} inode_t;

typedef struct
{
    char data[BLOCK_SIZE]; // Data block content
} datablock_t;

// Create a new struct similar to datablock_t that stores the name and inode number of the file
typedef struct
{
    char name[256];        // File name
    uint32_t inode_number; // Inode number
    uint32_t type;         // File type (regular or directory)
    uint32_t inuse;        // In-use flag
} directory_entry_t;

typedef struct
{
    directory_entry_t entries[BLOCK_SIZE / sizeof(directory_entry_t)]; // Directory entries
} directoryblock_t;

// Create a function read_directory_block that takes a directory block number and read the directory block from the segment file. If the directory block number is greater than 255 take divisor as a file name number and take the remainder as the directory block number. Read the segment file and read the directory block from the file. If the file is not found return -1. If the directory block is not found return -2. If the directory block is found return 0.
int read_directory_block(int directory_block_number, directoryblock_t *directory_block)
{
    uint8_t bitmap[BITMAP_BYTES];
    FILE *file = NULL;
    char filename[32];
    int segment_num = directory_block_number / 255;           // Calculate segment number
    int directory_block_index = directory_block_number % 255; // Calculate directory block index

    // Generate segment filename
    sprintf(filename, DATA_SEGMENT_NAME_PATTERN, segment_num);

    // Try to open the file
    file = fopen(filename, "r+b");
    if (file == NULL)
    {
        perror("Failed to open data segment file");
        return -1; // File not found
    }

    // Read the bitmap from the file
    if (fread(bitmap, sizeof(bitmap), 1, file) != 1)
    {
        fclose(file);
        return -2; // Failed to read bitmap
    }

    // Check if the directory block is used
    if (bitmap[directory_block_index] == 0)
    {
        fclose(file);
        return -2; // Directory block not found
    }

    // Read the directory block from the file
    fseek(file, (directory_block_index + 1) * BLOCK_SIZE, SEEK_SET);
    size_t read = fread(directory_block, sizeof(directoryblock_t), 1, file);
    fclose(file);

    if (read != 1)
    {
        return -2; // Failed to read directory block
    }

    return 0; // Success
}

// Create an function to read the inode from a segment file. If the inode number is greater than 255 take divisor as a file name number and take the remainder as the inode number. Read the segment file and read the inode from the file. If the file is not found return -1. If the inode is not found return -2. If the inode is found return 0.
int read_inode(int inode_number, inode_t *inode)
{
    uint8_t bitmap[BITMAP_BYTES];
    FILE *file = NULL;
    char filename[32];
    int segment_num = inode_number / 256; // Calculate segment number
    int inode_index = inode_number % 256; // Calculate inode index

    // Generate segment filename
    sprintf(filename, INODE_SEGMENT_NAME_PATTERN, segment_num);

    // Try to open the file
    file = fopen(filename, "r+b");
    if (file == NULL)
    {
        perror("Failed to open inode segment file");
        return -1; // File not found
    }

    // Read the bitmap from the file
    if (fread(bitmap, sizeof(bitmap), 1, file) != 1)
    {
        fclose(file);
        return -2; // Failed to read bitmap
    }

    // Check if the inode is used
    if (bitmap[inode_index] == 0)
    {
        fclose(file);
        return -2; // Inode not found
    }

    // Read the inode from the file
    fseek(file, (inode_index + 1) * INODE_SIZE, SEEK_SET);
    size_t read = fread(inode, sizeof(inode_t), 1, file);
    fclose(file);

    if (read != 1)
    {
        return -2; // Failed to read inode
    }

    return 0; // Success
}

// Create a read data block function that takes a datablock number and read the datablock from the segment file. If the datablock number is greater than 255 take divisor as a file name number and take the remainder as the datablock number. Read the segment file and read the datablock from the file. If the file is not found return -1. If the datablock is not found return -2. If the datablock is found return 0.
int read_datablock(int datablock_number, datablock_t *datablock)
{
    uint8_t bitmap[BITMAP_BYTES];
    FILE *file = NULL;
    char filename[32];
    int segment_num = datablock_number / 255;     // Calculate segment number
    int datablock_index = datablock_number % 255; // Calculate datablock index

    // Generate segment filename
    sprintf(filename, DATA_SEGMENT_NAME_PATTERN, segment_num);

    // Try to open the file
    file = fopen(filename, "r+b");
    if (file == NULL)
    {
        perror("Failed to open data segment file");
        return -1; // File not found
    }

    // Read the bitmap from the file
    if (fread(bitmap, sizeof(bitmap), 1, file) != 1)
    {
        fclose(file);
        return -2; // Failed to read bitmap
    }

    // Check if the datablock is used
    if (bitmap[datablock_index] == 0)
    {
        fclose(file);
        return -2; // Datablock not found
    }

    // Read the datablock from the file
    fseek(file, (datablock_index + 1) * DATA_SIZE, SEEK_SET);
    size_t read = fread(datablock, sizeof(datablock_t), 1, file);
    fclose(file);

    if (read != 1)
    {
        return -2; // Failed to read datablock
    }

    return 0; // Success
}

// Create an inode and save it to the first available free block in an available segment
int create_inode(inode_t *inode)
{
    uint8_t bitmap[BITMAP_BYTES];
    FILE *file = NULL;
    char filename[32];
    int segment_num = 0;
    int found_space = 0;

    // Try segments until we find one with free space
    while (!found_space)
    {
        // Generate segment filename
        sprintf(filename, INODE_SEGMENT_NAME_PATTERN, segment_num);

        // printf("Checking segment file %s...\n", filename);

        // Try to open the file
        file = fopen(filename, "r+b");
        if (file == NULL)
        {
            // File doesn't exist, create a new segment
            file = fopen(filename, "w+b");
            if (file == NULL)
            {
                perror("Failed to create inode segment file");
                return -1;
            }

            // Initialize new bitmap for this segment
            memset(&bitmap, 0, BITMAP_BYTES);

            fwrite(&bitmap, sizeof(bitmap), 1, file);
            found_space = 1;
        }
        else
        {
            // Read the bitmap from existing segment
            if (fread(bitmap, sizeof(bitmap), 1, file) != 1)
            {
                fclose(file);
                segment_num++;
                continue;
            }

            // Check if there's free space
            for (int i = 0; i < BITMAP_BYTES; i++)
            {
                if (bitmap[i] == 0)
                {
                    found_space = 1;
                    break;
                }
            }

            if (!found_space)
            {
                fclose(file);
                segment_num++;
            }
        }
    }

    // Find an empty block in the bitmap
    for (int i = 0; i < BITMAP_BYTES; i++)
    {
        if (bitmap[i] == 0)
        { // Check if the block is free
            // Mark the block as used
            bitmap[i] = 1;

            // printf("Current Bitmap: ");
            // for (int j = 0; j < BITMAP_BYTES; j++)
            // {
            //     printf("%u ", bitmap[j]);
            // }
            // printf("\n");

            // Update the bitmap in the file
            fseek(file, 0, SEEK_SET);
            fwrite(&bitmap, sizeof(bitmap), 1, file);

            // Write the inode to the file
            fseek(file, (i + 1) * INODE_SIZE, SEEK_SET);
            size_t written = fwrite(inode, sizeof(inode_t), 1, file);
            if (written != 1)
            {
                perror("Failed to write inode to file");
                fclose(file);
                return -1;
            }

            fclose(file);
            return i; // Return inode index for success
        }
    }

    // Should never reach here because we already checked for free space
    fclose(file);
    return -1;
}

int create_datablock(datablock_t *datablock)
{
    uint8_t bitmap[BITMAP_BYTES];
    FILE *file = NULL;
    char filename[32];
    int segment_num = 0;
    int found_space = 0;

    // Try segments until we find one with free space
    while (!found_space)
    {
        // Generate segment filename
        sprintf(filename, DATA_SEGMENT_NAME_PATTERN, segment_num);

        // printf("Checking segment file %s...\n", filename);

        // Try to open the file
        file = fopen(filename, "r+b");
        if (file == NULL)
        {
            // File doesn't exist, create a new segment
            file = fopen(filename, "w+b");
            if (file == NULL)
            {
                perror("Failed to create inode segment file");
                return -1;
            }

            // Initialize new bitmap for this segment
            memset(&bitmap, 0, BITMAP_BYTES);

            fwrite(&bitmap, sizeof(bitmap), 1, file);
            found_space = 1;
        }
        else
        {
            // Read the bitmap from existing segment
            if (fread(bitmap, sizeof(bitmap), 1, file) != 1)
            {
                fclose(file);
                segment_num++;
                continue;
            }

            // Check if there's free space
            for (int i = 0; i < BITMAP_BYTES; i++)
            {
                if (bitmap[i] == 0)
                {
                    found_space = 1;
                    break;
                }
            }

            if (!found_space)
            {
                fclose(file);
                segment_num++;
            }
        }
    }

    // Find an empty block in the bitmap
    for (int i = 0; i < BITMAP_BYTES; i++)
    {
        if (bitmap[i] == 0)
        { // Check if the block is free
            // Mark the block as used
            bitmap[i] = 1;

            // printf("Current Bitmap: ");
            // for (int j = 0; j < BITMAP_BYTES; j++)
            // {
            //     printf("%u ", bitmap[j]);
            // }
            // printf("\n");

            // Update the bitmap in the file
            fseek(file, 0, SEEK_SET);
            fwrite(&bitmap, sizeof(bitmap), 1, file);

            // Write the inode to the file
            fseek(file, (i + 1) * DATA_SIZE, SEEK_SET);
            size_t written = fwrite(datablock, sizeof(datablock_t), 1, file);
            if (written != 1)
            {
                perror("Failed to write inode to file");
                fclose(file);
                return -1;
            }

            fclose(file);
            return i; // Return data index for success
        }
    }

    // Should never reach here because we already checked for free space
    fclose(file);
    return -1;
}

// Create a function create_directoryblock that takes a directoryblock and create a directoryblock in the file system. The directoryblock is created same as the create_datablock function. The difference is that instead of storing the datablock it stores a directory_block. The function returns the index of the directoryblock.
int create_directoryblock(directoryblock_t *directory_block)
{
    uint8_t bitmap[BITMAP_BYTES];
    FILE *file = NULL;
    char filename[32];
    int segment_num = 0;
    int found_space = 0;

    // Try segments until we find one with free space
    while (!found_space)
    {
        // Generate segment filename
        sprintf(filename, DATA_SEGMENT_NAME_PATTERN, segment_num);

        // printf("Checking segment file %s...\n", filename);

        // Try to open the file
        file = fopen(filename, "r+b");
        if (file == NULL)
        {
            // File doesn't exist, create a new segment
            file = fopen(filename, "w+b");
            if (file == NULL)
            {
                perror("Failed to create inode segment file");
                return -1;
            }

            // Initialize new bitmap for this segment
            memset(&bitmap, 0, BITMAP_BYTES);

            fwrite(&bitmap, sizeof(bitmap), 1, file);
            found_space = 1;
        }
        else
        {
            // Read the bitmap from existing segment
            if (fread(bitmap, sizeof(bitmap), 1, file) != 1)
            {
                fclose(file);
                segment_num++;
                continue;
            }

            // Check if there's free space
            for (int i = 0; i < BITMAP_BYTES; i++)
            {
                if (bitmap[i] == 0)
                {
                    found_space = 1;
                    break;
                }
            }

            if (!found_space)
            {
                fclose(file);
                segment_num++;
            }
        }
    }

    // Find an empty block in the bitmap
    for (int i = 0; i < BITMAP_BYTES; i++)
    {
        if (bitmap[i] == 0)
        { // Check if the block is free
            // Mark the block as used
            bitmap[i] = 1;

            // printf("Current Bitmap: ");
            // for (int j = 0; j < BITMAP_BYTES; j++)
            // {
            //     printf("%u ", bitmap[j]);
            // }
            // printf("\n");

            // Update the bitmap in the file
            fseek(file, 0, SEEK_SET);
            fwrite(&bitmap, sizeof(bitmap), 1, file);

            // Write the inode to the file
            fseek(file, (i + 1) * DATA_SIZE, SEEK_SET);
            size_t written = fwrite(directory_block, sizeof(directoryblock_t), 1, file);
            if (written != 1)
            {
                perror("Failed to write inode to file");
                fclose(file);
                return -1;
            }
            fclose(file);
            // Returning the overall index of the directory block
            return (segment_num * 255) + i; // Return data index for success
        }
    }
    // Should never reach here because we already checked for free space
    fclose(file);
    return -1;
}

// Create a function add_directoryentry_to_directoryblock that takes a directoryblock and update its array of directory entires. The function takes in directoryblock and a directory entry and adds that directory entry to the directoryblock. The function returns 0 on success and -1 on failure.

int add_directoryentry_to_directoryblock(uint32_t directoryblock_index, directory_entry_t *entry)
{
    directoryblock_t directory_block;

    // Read the existing directory block
    int result = read_directory_block(directoryblock_index, &directory_block);
    if (result < 0)
    {
        return result; // Failed to read the directory block
    }

    // Check if there's space for a new entry
    for (int i = 0; i < BLOCK_SIZE / sizeof(directory_entry_t); i++)
    {
        if (directory_block.entries[i].inuse != 1)
        {
            // Add the new entry to the first empty slot
            directory_block.entries[i] = *entry;

            // Update the directory block in the file
            uint8_t bitmap[BITMAP_BYTES];
            FILE *file = NULL;
            char filename[32];
            int segment_num = directoryblock_index / 255;
            int block_index = directoryblock_index % 255;

            sprintf(filename, DATA_SEGMENT_NAME_PATTERN, segment_num);
            file = fopen(filename, "r+b");
            if (file == NULL)
            {
                return -1;
            }

            // Skip the bitmap
            fseek(file, (block_index + 1) * BLOCK_SIZE, SEEK_SET);

            // Write the updated directory block
            if (fwrite(&directory_block, sizeof(directoryblock_t), 1, file) != 1)
            {
                fclose(file);
                return -1;
            }

            fclose(file);

            return 0; // Success
        }
    }

    return -1; // Directory block is full
}

// Create a function create_directory that takes a directory name and create a directory in the file system. The directory is created by creating a datablock and writing the directory name to the datablock. The datablock is then saved to the first available free block in an available segment. The function returns the index of the datablock. The second paramter is the inode number of the parent directory. The function creates a directory entry in the parent directory for the new directory. If the second parameter is not provided then the parent directory is set to have inode number 0. The function returns the index of the datablock.
// It creates a directory entry in the parent directory for the new directory. If the second parameter is not provided then the parent directory is set to have inode number 0. The function returns the index of the datablock.
int create_directory(const char *directory_name, int parent_inode_number)
{
    directoryblock_t directory_block;
    uint32_t block_count = 0;

    // Create a new directory entry
    directory_entry_t new_entry;
    strncpy(new_entry.name, directory_name, sizeof(new_entry.name) - 1);
    new_entry.name[sizeof(new_entry.name) - 1] = '\0'; // Ensure null termination
    new_entry.inode_number = 0;                        // Placeholder for inode number
    new_entry.type = FILE_TYPE_DIRECTORY;              // Directory type
    new_entry.inuse = 1;                               // Mark as in-use

    // Initialize the directory block
    memset(&directory_block, 0, sizeof(directoryblock_t));
    memcpy(&directory_block.entries[0], &new_entry, sizeof(directory_entry_t));

    // Create a datablock and store its index
    int directoryblock_index = create_directoryblock(&directory_block);
    if (directoryblock_index < 0)
    {
        perror("Failed to create datablock");
        return -1;
    }

    // Save the datablock index in the parent inode's direct blocks
    if (parent_inode_number > 0)
    {
        inode_t parent_inode;
        if (read_inode(parent_inode_number, &parent_inode) != 0)
        {
            perror("Failed to read parent inode");
            return -1;
        }

        for (int i = 0; i < MAX_DIRECT_BLOCKS; i++)
        {
            if (parent_inode.direct_blocks[i] == 0)
            {
                parent_inode.direct_blocks[i] = directoryblock_index;
                break;
            }
        }

        // Update the parent inode in the segment file
        FILE *segment_file = fopen(INODE_SEGMENT_NAME_PATTERN, "r+b");
        if (segment_file == NULL)
        {
            perror("Failed to open segment file");
            return -1;
        }
        fseek(segment_file, (parent_inode_number + 1) * INODE_SIZE, SEEK_SET);
        fwrite(&parent_inode, sizeof(inode_t), 1, segment_file);
        fclose(segment_file);
    }

    return directoryblock_index; // Return the index of the created datablock
}

// Function that takes a file path and create a inode for that file and save it to the first available free block in an available segment and then create a datablock for that file and save it to the first available free block in an available segment. Save the datablock index in the inode.direct_blocks[0].
int create_inode_for_file(const char *file_path)
{
    inode_t inode;
    datablock_t datablock;
    uint32_t block_count = 0;

    // Reading the actual file data
    FILE *file = fopen(file_path, "rb");
    if (file == NULL)
    {
        perror("Failed to open file");
        return -1;
    }

    // Get file size
    fseek(file, 0, SEEK_END);
    inode.size = ftell(file);
    fseek(file, 0, SEEK_SET);

    // Calculate how many blocks we need
    block_count = (inode.size + BLOCK_SIZE - 1) / BLOCK_SIZE; // Ceiling division
    if (block_count > MAX_DIRECT_BLOCKS)
    {
        fprintf(stderr, "File too large for direct blocks only\n");
        fclose(file);
        return -1;
    }

    // prefill inode MAX_DIRECT_BLOCKS with 0
    for (int i = 0; i < MAX_DIRECT_BLOCKS; i++)
    {
        inode.direct_blocks[i] = 0;
    }

    // Read file data in chunks and create datablocks
    for (uint32_t i = 0; i < block_count; i++)
    {
        // Clear the datablock
        memset(&datablock, 0, sizeof(datablock_t));

        // Read up to BLOCK_SIZE bytes into the datablock
        size_t bytes_read = fread(datablock.data, 1, BLOCK_SIZE, file);

        // Create a datablock and store its index
        int datablock_index = create_datablock(&datablock);
        if (datablock_index < 0)
        {
            perror("Failed to create datablock");
            fclose(file);
            return -1;
        }

        // Save datablock index in inode
        inode.direct_blocks[i] = datablock_index;
    }

    printf("Total Block Count %d\n", block_count);

    // Print the inode.direct_blocks that was going to be written to the file
    printf("Inode Direct Blocks: ");
    for (int i = 0; i < block_count; i++)
    {
        printf("%u ", inode.direct_blocks[i]);
    }
    printf("\n");

    fclose(file);

    inode.type = FILE_TYPE_REGULAR; // Regular file
    inode.single_indirect = 0;
    inode.double_indirect = 0;
    //  inode.triple_indirect = 0;
    // for (int i = 0; i < MAX_DIRECT_BLOCKS; i++)
    // {
    //     inode.direct_blocks[i] = 0; // Initialize direct blocks
    // }
    // Create inode and datablock

    int inode_index = create_inode(&inode);
    if (inode_index < 0)
    {
        perror("Failed to create inode");
        return -1;
    }

    // // Update inode in the segment file
    // FILE *segment_file = fopen(INODE_SEGMENT_NAME_PATTERN, "r+b");
    // if (segment_file == NULL)
    // {
    //     perror("Failed to open segment file");
    //     return -1;
    // }
    // fseek(segment_file, (inode_index + 1) * INODE_SIZE, SEEK_SET);
    // fwrite(&inode, sizeof(inode_t), 1, segment_file);
    // fclose(segment_file);
    return inode_index;
}

// Split a path into segments and return the count of segments
int split_path(const char *path, char *segments[], int max_segments)
{
    char path_copy[256]; // Create a copy since strtok modifies the string
    strncpy(path_copy, path, sizeof(path_copy) - 1);
    path_copy[sizeof(path_copy) - 1] = '\0'; // Ensure null termination

    int segment_count = 0;
    char *segment = strtok(path_copy, "/");

    while (segment != NULL && segment_count < max_segments)
    {
        segments[segment_count++] = strdup(segment);
        segment = strtok(NULL, "/");
    }
    segments[segment_count] = NULL;

    return segment_count;
}

// Create a function to add file to the filesystem
int add_file(const char *fs_path, const char *local_file)
{

    // In the add_file function:
    char *path_segments[10];
    int segment_count = split_path(fs_path, path_segments, 10);

    // // Print the segments
    // printf("Path Segments:\n");
    // for (int i = 0; i < segment_count; i++)
    // {
    //     printf("%s\n", path_segments[i]);
    // }

    size_t inode_index = create_inode_for_file(local_file);
    if (inode_index < 0)
    {
        fprintf(stderr, "Failed to create inode for file\n");
        return -1;
    }

    // Adding the current file to the root directory
    directory_entry_t new_entry;
    new_entry.inode_number = inode_index; // Placeholder for inode number
    new_entry.type = FILE_TYPE_REGULAR;
    strncpy(new_entry.name, path_segments[segment_count - 1], sizeof(new_entry.name) - 1);
    new_entry.name[sizeof(new_entry.name) - 1] = '\0';   // Ensure null termination
                                                         // Directory type
    new_entry.inuse = 1;                                 // Mark as in-use
    add_directoryentry_to_directoryblock(0, &new_entry); // Adding the file to the root directory
}

// Create a function to extract a file from the file system. The function takes a path as input and extracts the file from the file system. The function returns 0 on success and -1 on failure.
int extract_file(const char *path)
{
    // In the add_file function:
    char *path_segments[10];
    int segment_count = split_path(path, path_segments, 10);

    // Print the segments
    printf("Path Segments:\n");
    for (int i = 0; i < segment_count; i++)
    {
        printf("%s\n", path_segments[i]);
    }

    inode_t extracted_inode;

    // Reading from the second inode segment, marking the inode_number as 1
    // TODO: Read the inode number recursively from the path
    int result = read_inode(1, &extracted_inode);

    if (result < 0)
    {
        fprintf(stderr, "Failed to read inode\n");
        return -1;
    }

    // printf("Inode read successfully:\n");
    // printf("Type: %u\n", extracted_inode.type);
    // printf("Size: %lu\n", extracted_inode.size);
    // printf("Direct blocks: ");
    // for (int i = 0; i < MAX_DIRECT_BLOCKS; i++)
    // {
    //     printf("%u ", extracted_inode.direct_blocks[i]);
    // }
    // printf("\n");
    // printf("Single indirect: %u\n", extracted_inode.single_indirect);
    // printf("Double indirect: %u\n", extracted_inode.double_indirect);

    // From the list of direct blocks, read the datablocks and print their contents
    for (int i = 0; i < MAX_DIRECT_BLOCKS; i++)
    {

        if (extracted_inode.direct_blocks[i] == 0)
        {
            break; // No more direct blocks
        }

        datablock_t datablock;

        int result = read_datablock(extracted_inode.direct_blocks[i], &datablock);
        if (result < 0)
        {
            fprintf(stderr, "Failed to read datablock\n");
            return -1;
        }

        // printf("%u", extracted_inode.direct_blocks[i]);

        for (int j = 0; j < BLOCK_SIZE; j++)
        {
            printf("%c", datablock.data[j]);
        }
    }

    return 0;
}

// Create a function to debug the path. This function takes prints the bitmap of all the segments and inodes files. Both INODE_SEGMENT_NAME_PATTERN and DATA_SEGMENT_NAME_PATTERN inital bitmap are printed here.
int debug_path(const char *path)
{
    // In the add_file function:
    char *path_segments[10];
    int segment_count = split_path(path, path_segments, 10);

    // Print the segments
    printf("Path Segments:\n");
    for (int i = 0; i < segment_count; i++)
    {
        printf("%s\n", path_segments[i]);
    }

    // Print the bitmap of all the segments and inodes files
    int segment_num = 0;
    char filename[32];
    FILE *file = NULL;
    uint8_t bitmap[BITMAP_BYTES];

    // Check inode segments
    while (1)
    {
        // Generate segment filename
        sprintf(filename, INODE_SEGMENT_NAME_PATTERN, segment_num);

        // Try to open the file
        file = fopen(filename, "rb");
        if (file == NULL)
        {
            // No more inode segments
            break;
        }

        // Read the bitmap from the file
        if (fread(bitmap, sizeof(bitmap), 1, file) != 1)
        {
            perror("Failed to read bitmap");
            fclose(file);
            return -2;
        }

        printf("Bitmap of %s: ", filename);
        for (int j = 0; j < BITMAP_BYTES; j++)
        {
            printf("%u ", bitmap[j]);
        }
        printf("\n");

        // From the bitmap, list all the inode details that are in use
        for (int i = 0; i < BITMAP_BYTES; i++)
        {
            if (bitmap[i] == 1)
            {
                inode_t inode;
                int result = read_inode(i, &inode);
                if (result < 0)
                {
                    fprintf(stderr, "Failed to read inode\n");
                    fclose(file);
                    return -2;
                }
                printf("Inode %d: Type: %u, Size: %lu", i, inode.type, inode.size);
                printf("Direct blocks: ");
                for (int k = 0; k < MAX_DIRECT_BLOCKS; k++)
                {
                    printf("%u ", inode.direct_blocks[k]);
                }
                printf("\n");
            }
        }

        printf("\n");

        fclose(file);
        segment_num++;
    }

    // Reset segment_num for data segments
    segment_num = 0;

    // Check data segments
    while (1)
    {
        // Generate segment filename
        sprintf(filename, DATA_SEGMENT_NAME_PATTERN, segment_num);

        // Try to open the file
        file = fopen(filename, "rb");
        if (file == NULL)
        {
            // No more data segments
            break;
        }

        // Read the bitmap from the file
        if (fread(bitmap, sizeof(bitmap), 1, file) != 1)
        {
            perror("Failed to read bitmap");
            fclose(file);
            return -2;
        }

        printf("Bitmap of %s: ", filename);
        for (int j = 0; j < BITMAP_BYTES; j++)
        {
            printf("%u ", bitmap[j]);
        }
        printf("\n");

        // From the bitmap, list all the datablock details that are in use
        for (int i = 0; i < BITMAP_BYTES; i++)
        {
            if (bitmap[i] == 1)
            {
                // First read it as a datablock to check the content
                datablock_t datablock;
                int result = read_datablock(i, &datablock);
                if (result < 0)
                {
                    fprintf(stderr, "Failed to read datablock\n");
                    fclose(file);
                    return -2;
                }

                // Try to read it as a directory block to check if it has valid entries
                directoryblock_t directory_block;
                if (read_directory_block(i, &directory_block) == 0)
                {
                    // Check if first entry is valid (simple heuristic to determine if it's a directory)
                    if (directory_block.entries[0].inuse == 1)
                    {
                        printf("Datablock %d: Directory Block, First entry: %s (inode: %u)\n",
                               i, directory_block.entries[0].name, directory_block.entries[0].inode_number);
                        continue;
                    }
                }

                // Otherwise print as regular datablock
                printf("Datablock %d: Regular Block, Size: %lu\n", i, sizeof(datablock.data));
            }
        }
        printf("\n");

        fclose(file);
        segment_num++;
    }

    return 0;
}

// Print entries in current directory
static void print_directory(int inode_number, int depth)
{
    directoryblock_t dir_block;
    int result = read_directory_block(inode_number, &dir_block);
    if (result < 0)
        return;

    for (int i = 0; i < BLOCK_SIZE / sizeof(directory_entry_t); i++)
    {
        if (dir_block.entries[i].inuse == 1)
        {
            // Print indentation
            for (int j = 0; j < depth; j++)
            {
                printf("│   ");
            }

            printf("├── %s [Inode: %u, %s]\n",
                   dir_block.entries[i].name,
                   dir_block.entries[i].inode_number,
                   dir_block.entries[i].type == FILE_TYPE_DIRECTORY ? "Directory" : "File");

            // Recursively list subdirectories with increased depth
            if (dir_block.entries[i].type == FILE_TYPE_DIRECTORY)
            {
                print_directory(dir_block.entries[i].inode_number, depth + 1);
            }
        }
    }
}

// This function named list_directory() will list all recursively fetch all the inodes details from the directories entries of the root directory. If the fetched inode is a directory then it will recursively fetch all the inodes details from the directories entries of the fetched inode. The function will print the name of the file and its inode number. The function will return 0 on success and -1 on failure.
int list_directory(int inode_number)
{
    directoryblock_t directory_block;
    int result = read_directory_block(inode_number, &directory_block); // Read the root directory block

    if (result < 0)
    {
        fprintf(stderr, "Failed to read root directory block\n");
        return -1;
    }

    // Start recursive printing from depth 0
    printf("root\n");
    print_directory(inode_number, 0);

    return 0;
}

// Create a function to initialize the file system that creates the first inode and first datasegments of the file system. The first inode is the root inode and the first datasegment is the root datasegment. The root inode is a directory and the root datasegment is a directory.
int init_file_system()
{
    inode_t inode;
    directoryblock_t directoryblock;
    char inodeseg_filename[32];
    char dataseg_filename[32];

    sprintf(inodeseg_filename, INODE_SEGMENT_NAME_PATTERN, 0);
    sprintf(dataseg_filename, DATA_SEGMENT_NAME_PATTERN, 0);

    // Try to read the first inode segment and first data segment, if they exist the file system is already initialized
    FILE *inode_segment = fopen(inodeseg_filename, "r");
    FILE *data_segment = fopen(dataseg_filename, "r");

    if (data_segment != NULL && inode_segment == NULL)
    {
        fclose(data_segment);
        return 0; // File system already initialized
    }
    else
    {

        // directoryblock.entries[0].inode_number = 0;
        // directoryblock.entries[0].type = FILE_TYPE_DIRECTORY;
        // directoryblock.entries[0].inuse = 1;
        // strncpy(directoryblock.entries[0].name, "root", sizeof(directoryblock.entries[0].name) - 1);
        // directoryblock.entries[0].name[sizeof(directoryblock.entries[0].name) - 1] = '\0'; // Ensure null termination

        memset(&directoryblock, 0, sizeof(directoryblock_t));

        int root_directoryblock_index = create_directoryblock(&directoryblock);

        // printf("Root Datablock Index: %d\n", root_directoryblock_index);

        // fill MAX_DIRECT_BLOCKS with 0
        for (int i = 0; i < MAX_DIRECT_BLOCKS; i++)
        {
            inode.direct_blocks[i] = 0; // Initialize direct blocks
        }

        inode.direct_blocks[0] = root_directoryblock_index;
        inode.type = FILE_TYPE_DIRECTORY; // Directory type
        inode.size = 0;                   // Size is initially 0
        inode.single_indirect = 0;
        inode.double_indirect = 0;

        int root_inode_index = create_inode(&inode);
        if (root_inode_index < 0)
        {
            fprintf(stderr, "Failed to create root inode\n");
            return -1;
        }

        return 0;
    }
}

/*
 * Implementation
 */

int main(int argc, char *argv[])
{
    int opt;
    char *fs_path = NULL;
    char *local_file = NULL;

    // Initialize file system
    if (init_file_system() != 0)
    {
        fprintf(stderr, "Failed to initialize file system\n");
        return 1;
    }

    // Parse command line arguments
    while ((opt = getopt(argc, argv, "la:f:r:e:D:")) != -1)
    {
        switch (opt)
        {
        case 'l': // List directory
            return list_directory(0);

        case 'a': // Add file path
            fs_path = optarg;
            break;

        case 'f': // File to add
            local_file = optarg;
            break;

        case 'r': // Remove file
            return 0;
            // return remove_file(optarg);

        case 'e': // Extract file
            return extract_file(optarg);

        case 'D': // Debug path
            return debug_path(optarg);

        default:
            fprintf(stderr, "Usage: %s [-l] [-a fs_path -f local_file] [-r path] [-e path] [-D path]\n", argv[0]);
            return 1;
        }
    }

    // Handle adding a file if both -a and -f were specified
    if (fs_path != NULL && local_file != NULL)
    {

        return add_file(fs_path, local_file);
    }
    else if (fs_path != NULL || local_file != NULL)
    {
        fprintf(stderr, "Both -a and -f must be specified together\n");
        return 1;
    }

    // Default action if no arguments were provided
    fprintf(stderr, "Usage: %s [-l] [-a fs_path -f local_file] [-r path] [-e path] [-D path]\n", argv[0]);
    return 1;
}